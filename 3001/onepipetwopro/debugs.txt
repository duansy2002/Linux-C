利用sleep函数解决O_RDWR模式下，会读取本进程输入的问题。加入延时可以完美解决！

分析一下。分为两种状态
状态1-READ模式：
	管道文件活动-》读管道-》输出字符
状态2-WRITE模式：
	stdin活动-》写入管道-》进入进程2
由于状态2可以在自身的进程中进入状态1 ，也就是一种闭合状态，所以我要切断他。
那么我的延时切断的是自身的由2-》1的过程。
即――――
每当有stdin标准输入的时候，必然会进入别的进程
而不是本进程，因为本进程的输入无论如何都会
晚于其他进程，因为延时的存在！

2015-1-31 01:29:51
v2版本---》采用了写入EOF字符作为结束的方法
效果是――CTRL D一个程序后另一个程序也会关闭
2015-1-31 08:03:37
昨晚回去后想了一下，服务器会一直输出退出的管道中的信息，这是因为在服务端分发消息时，同样分发给了来源，而来源因为有sleep不会立即进入接受态。因此在1秒内，服务器端一直显示当前传入数据
解决方案---》
	1-加入来源过滤，即不发送给来源。过滤的select错误的选成了0，会造成except失败
	还是用if比较好！！
	2-for循环中加break可以提高性能

3-服务器端加入延迟《--不可取，性能下降

加入排除机制：
如果子端在sleep期间，服务器又发出一个信号，那么该信号会被服务器自己读取。
所以加入set的时候先判断pipe是否写完
或者还是用WRONLY模式？
bug---
一端输入，其他端就会没反应
好像被屏蔽

发现一个重要特性！当select一个端口活动后，其他端口会被踢出！
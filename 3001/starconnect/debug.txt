加入排除机制：
如果子端在sleep期间，服务器又发出一个信号，那么该信号会被服务器自己读取。
所以加入set的时候先判断pipe是否写完
或者还是用WRONLY模式？

BUG2——子端占用，会反复写1、2、1、2直到子端可用。而又因为子端1先可用，最后结束的一定是子端1读取而不是子端2.这在三端下会造成连续阻塞，也就是累计许多内容到fifo中

解决：加入等待语句 ，直到FD_ISSET n都为不活动才执行下一次循环
————————————————————————————————————————————————————————————
debug2015-1-31 11:47:00
延时函数优化——
连续读可用的，把sleep移动到写即可

select检测到活动的端口会踢出去其他不活动的，而且当前端口会一直保持活动直到下一次reset。于是造成我的程序一直死循环而跳不出while语句

既然我都没有write活动端口，干脆将活动端口去掉

fflush 是否会导致0端口活动？
不会！

在服务端加入延迟竟然就可以不出问题，请分析.
set进入后竟然ISSET默认是1
查阅函数原型后，我觉得是因为RDWR的问题，文件随时准备好读取因此就会出现问题

不是这样的，是因为select执行之后，效果是踢掉所有不活动的量，于是初始化肯定会出错的
=====================================================
问题来了，我加上一个sleep在末尾就可以了
发现剩下的一个输入会活跃一段时间，但是过一会就会变0

select 延时失败，改成了usleep延时！！！！！！！！！

竟然就这么好了！！！！！！！！
下面解决的问题是——子端退出N个，会重复发送N次
===》》》》添加功能：过滤子端
